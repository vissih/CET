//@version=5
indicator("testing", overlay = true, max_bars_back = 500, max_lines_count=500, max_labels_count=500)

//engulfing candle code
//start

var float openBarPrevious = na
var float closeBarPrevious = na
var float openBarCurrent = na
var float closeBarCurrent = na

if bar_index > 0
    openBarPrevious := open[1]
    closeBarPrevious := close[1]

openBarCurrent := open
closeBarCurrent := close

bullishEngulfing = (openBarCurrent <= closeBarPrevious) and (openBarCurrent < openBarPrevious) and (closeBarCurrent > openBarPrevious)
bearishEngulfing = (openBarCurrent >= closeBarPrevious) and (openBarCurrent > openBarPrevious) and (closeBarCurrent < openBarPrevious)

plotshape(bullishEngulfing, style = shape.triangleup, location = location.belowbar, color = color.green, size = size.tiny)
plotshape(bearishEngulfing, style = shape.triangledown, location = location.abovebar, color = color.red, size = size.tiny)

alertcondition(bullishEngulfing, title = "Bullish Engulfing", message = "[CurrencyPair] [TimeFrame], Bullish candle engulfing previous candle")
alertcondition(bearishEngulfing, title = "Bearish Engulfing", message = "[CurrencyPair] [TimeFrame], Bearish candle engulfing previous candle")

//end

//halftrend code
//start

amplitude = input.int(title="Amplitude", defval=2)
channelDeviation = input.int(title="Channel Deviation", defval=2)
showArrows = input.bool(title="Show Arrows", defval=true)
showChannels = input.bool(title="Show Channels", defval=true)

var trend = 0
var nextTrend = 0
var maxLowPrice = na(low[1]) ? low : low[1]
var minHighPrice = na(high[1]) ? high : high[1]

var float up = 0.0
var float down = 0.0
var float atrHigh = 0.0
var float atrLow = 0.0
var float arrowUp = na
var float arrowDown = na

atr2 = ta.atr(100) / 2
dev = channelDeviation * atr2

highPrice = high[math.abs(ta.highestbars(amplitude))]
lowPrice = low[math.abs(ta.lowestbars(amplitude))]
highma = ta.sma(high, amplitude)
lowma = ta.sma(low, amplitude)

if nextTrend == 1
    maxLowPrice := math.max(lowPrice, maxLowPrice)
    if highma < maxLowPrice and close < low[1]
        trend := 1
        nextTrend := 0
        minHighPrice := highPrice
else
    minHighPrice := math.min(highPrice, minHighPrice)
    if lowma > minHighPrice and close > high[1]
        trend := 0
        nextTrend := 1
        maxLowPrice := lowPrice

if trend == 0
    if not na(trend[1]) and trend[1] != 0
        up := na(down[1]) ? down : down[1]
        arrowUp := up - atr2
    else
        up := na(up[1]) ? maxLowPrice : math.max(maxLowPrice, up[1])
    atrHigh := up + dev
    atrLow := up - dev
else
    if not na(trend[1]) and trend[1] != 1 
        down := na(up[1]) ? up : up[1]
        arrowDown := down + atr2
    else
        down := na(down[1]) ? minHighPrice : math.min(minHighPrice, down[1])
    atrHigh := down + dev
    atrLow := down - dev

ht = trend == 0 ? up : down

var color buyColor = color.blue
var color sellColor = color.red

htColor = trend == 0 ? buyColor : sellColor
htPlot = plot(ht, title="HalfTrend", linewidth=2, color=htColor)

atrHighPlot = plot(showChannels ? atrHigh : na, title="ATR High", style=plot.style_circles, color=sellColor)
atrLowPlot = plot(showChannels ? atrLow : na, title="ATR Low", style=plot.style_circles, color=buyColor)

fill(htPlot, atrHighPlot, title="ATR High Ribbon", color=sellColor)
fill(htPlot, atrLowPlot, title="ATR Low Ribbon", color=buyColor)

buySignal = not na(arrowUp) and (trend == 0 and trend[1] == 1)
sellSignal = not na(arrowDown) and (trend == 1 and trend[1] == 0)

plotshape(showArrows and buySignal ? atrLow : na, title="Arrow Up", style=shape.triangleup, location=location.absolute, size=size.tiny, color=buyColor)
plotshape(showArrows and sellSignal ? atrHigh : na, title="Arrow Down", style=shape.triangledown, location=location.absolute, size=size.tiny, color=sellColor)

alertcondition(buySignal, title="Alert: HalfTrend Buy", message="HalfTrend Buy")
alertcondition(sellSignal, title="Alert: HalfTrend Sell", message="HalfTrend Sell")

//end

//zigzag waves
//start

//indicator('Zigzag Chart Points', 'ZCP', true, max_bars_back = 500)

// 0. Inputs
// 1. Variables and arrays
// 2. Map
// 3. Switches
// 4. Methods
// 5. Executions

//#region ———————————————————— 0. Inputs
G0         = 'Main Settings'
T0         = 'Zigzag values\nDefault : 14\nMin : 2\nMax : 50'
length     = input.int(            14,      'Length', group = G0, minval = 2, maxval = 50, tooltip = T0)
colorUp    = input.color(color.lime,       'Trend', group = G0, inline = '0')
colorDn    = input.color( color.red,            '', group = G0, inline = '0')

G1         = 'Line Settings'
T1         = 'Default\nStyle : Solid\nWidth : 4'
showLine   = input.bool(         true, 'Show / hide', group = G1)
lineType   = input.string(    'solid',       'Style', group = G1, options = ['dash', 'dot', 'solid', 'arrow right', 'arrow left'])
extendType = input.string(    'none',       'Extend', group = G1, options = ['left', 'right', 'both', 'none'])
width      = input.int(             4,       'Width', group = G1, minval = 1, maxval = 4, tooltip = T1)

G2         = 'Label Settings'
T2         = 'Small font size recommended for mobile app or multiple layout'
showLabel  = input.bool(         true, 'Show / hide', group = G2)
fontSize   = input.string(   'normal',        'Size', group = G2, options = ['tiny',  'small', 'normal', 'large', 'huge'], tooltip = T2)
//#endregion

//#region ———————————————————— 1. Variables and arrays
float ph      = na,  ph := ta.highestbars(high, length) == 0 ? high : na
float pl      = na,  pl := ta.lowestbars(  low, length) == 0 ?  low : na  
var  dir      =  0, dir := not na(ph) and na(pl) ? 1 : not na(pl) and na(ph) ? -1 : dir
var zigzag    = array.new<chart.point>(0)
oldzigzag     = zigzag.copy()
dirchanged    = dir[0] != dir[1]
var arraySize = 10
//#endregion

//#region ———————————————————— 2. Map
// Create map for label's tooltip
tip = map.new<string, string>()
tip.put('HH', 'HIGHER HIGH')
tip.put('LH', 'LOWER HIGH')
tip.put('LL', 'LOWER LOW')
tip.put('HL', 'HIGHER LOW')
//#endregion

//#region ———————————————————— 3. Switches
switchLine        = switch lineType
    'dash'        => line.style_dashed
    'dot'         => line.style_dotted
    'solid'       => line.style_solid
    'arrow right' => line.style_arrow_right
    'arrow left'  => line.style_arrow_left
switchExtend      = switch extendType
    'left'        => extend.left
    'right'       => extend.right
    'both'        => extend.both
    'none'        => extend.none
//#endregion

//#region ———————————————————— 4. Methods
// @function     addPoint
// @param           price   float value
// @param           index   int value
// @param       arraySize   array size for chart.point[]
// @returns chart.point[] 
method addPoint(chart.point[] id, float price = na, int index = na, int arraySize = na) =>
    id.unshift(chart.point.new(time, index, price))
    if id.size() > arraySize
        id.pop()

// @function updatePoints
// @param           price   float value
// @param           index   int value
// @param       arraySize   array size for chart.point[]
// @param             dir   int value
// @returns chart.point[] 
method updatePoints(chart.point[] id, float price = na, int index = na, int arraySize = na, int dir = na) =>
    if id.size() == 0
        id.addPoint(price, index)
    else
        if dir == 1 and price > id.get(0).price or dir == -1 and price < id.get(0).price 
            id.set(0, chart.point.new(time, index, price))
        chart.point.new(na, na, na)
//#endregion

//#region ———————————————————— 5. Executions
if na(ph) or na(pl)
    if dirchanged
        zigzag.addPoint(dir == 1 ? ph : pl, bar_index, arraySize)
    else
        zigzag.updatePoints(dir == 1 ? ph : pl, bar_index, arraySize, dir)

if zigzag.size() >= 3 and oldzigzag.size() >= 3
    var line  linezigzag  = na
    var label labelzigzag = na
    if     zigzag.get(0).index != oldzigzag.get(0).index or  zigzag.get(0).price != oldzigzag.get(0).price
        if zigzag.get(1).index == oldzigzag.get(1).index and zigzag.get(1).price == oldzigzag.get(1).price
            linezigzag.delete()
            labelzigzag.delete()
        if showLine
            linezigzag  := line.new(
                                     first_point  = zigzag.get(0),
                                     second_point = zigzag.get(1),
                                     xloc         = xloc.bar_index,
                                     extend       = switchExtend,
                                     color        = dir == 1 ? colorUp : colorDn,
                                     style        = switchLine,
                                     width        = width)
        if showLabel
            textzigzag   = dir == 1 ?    zigzag.get(0).price > zigzag.get(2).price ? 'HH'    : 'LH' :
                                         zigzag.get(0).price < zigzag.get(2).price ? 'LL'    : 'HL'
            colorzigzag  = dir == 1 ?    zigzag.get(0).price > zigzag.get(2).price ? colorDn : colorUp :
                                         zigzag.get(0).price < zigzag.get(2).price ? colorUp : colorDn
            currentRes   = timeframe.isintraday ? 'dd-MMM-yyyy HH:mm' : 'dd-MMM-yyyy'
            labelzigzag := label.new(
                                     point     = zigzag.get(0),
                                     text      =  textzigzag,
                                     xloc      = xloc.bar_index,
                                     style     = dir == 1 ? label.style_label_down : label.style_label_up,
                                     color     = color.new(color.blue, 100),
                                     textcolor = colorzigzag,
                                     size      = fontSize,
                                     tooltip   = tip.get(textzigzag) + '\n' +
                                                 'Time  : ' + str.format_time(zigzag.get(0).time, currentRes, syminfo.timezone)+ '\n' +
                                                 'Price : ' + str.tostring(zigzag.get(0).price))
//#endregion

//end

//ydh-ydl-ydl
//start

// Inputs for displaying levels
showHigh = input.bool(true, "Show Prior Day High", group="Display Options")
showMiddle = input.bool(true, "Show Prior Day Halfback", group="Display Options")
showLow = input.bool(true, "Show Prior Day Low", group="Display Options")

// Inputs for displaying labels
showHighLabel = input.bool(true, "Show Prior Day High Label", group="Display Options")
showMiddleLabel = input.bool(true, "Show Prior Day Halfback Label", group="Display Options")
showLowLabel = input.bool(true, "Show Prior Day Low Label", group="Display Options")

// Inputs for line colors
highLineColor = input.color(color.green, "Prior Day High Line Color", group="Line Colors")
middleLineColor = input.color(color.blue, "Prior Day Halfback Line Color", group="Line Colors")
lowLineColor = input.color(color.red, "Prior Day Low Line Color", group="Line Colors")

// Fetch yesterday's high, low, and calculate the middle
yHigh = request.security(syminfo.tickerid, "D", high[1])
yLow = request.security(syminfo.tickerid, "D", low[1])
yMiddle = (yHigh + yLow) / 2

// Plotting lines based on user choices
var line highLine = na
var line middleLine = na
var line lowLine = na

if showHigh
    if na(highLine)
        highLine := line.new(bar_index[1], yHigh, bar_index, yHigh, width=2, color=highLineColor, extend=extend.both)
    else
        line.set_xy1(highLine, bar_index[1], yHigh)
        line.set_xy2(highLine, bar_index, yHigh)
        line.set_color(highLine, highLineColor)

if showMiddle
    if na(middleLine)
        middleLine := line.new(bar_index[1], yMiddle, bar_index, yMiddle, width=2, color=middleLineColor, extend=extend.both)
    else
        line.set_xy1(middleLine, bar_index[1], yMiddle)
        line.set_xy2(middleLine, bar_index, yMiddle)
        line.set_color(middleLine, middleLineColor)

if showLow
    if na(lowLine)
        lowLine := line.new(bar_index[1], yLow, bar_index, yLow, width=2, color=lowLineColor, extend=extend.both)
    else
        line.set_xy1(lowLine, bar_index[1], yLow)
        line.set_xy2(lowLine, bar_index, yLow)
        line.set_color(lowLine, lowLineColor)

// Plotting labels based on user choices
var label highLabel = na
var label middleLabel = na
var label lowLabel = na

if showHighLabel
    if na(highLabel)
        highLabel := label.new(bar_index, yHigh, "Prior Day High: " + str.tostring(yHigh), xloc.bar_index, yloc.price, color=highLineColor, style=label.style_label_down, size=size.small, textcolor=color.white, textalign=text.align_right)
    else
        label.set_xy(highLabel, bar_index, yHigh)
        label.set_text(highLabel, "Prior Day High: " + str.tostring(yHigh))
        label.set_color(highLabel, highLineColor)
        label.set_style(highLabel, label.style_label_down)

if showMiddleLabel
    if na(middleLabel)
        middleLabel := label.new(bar_index, yMiddle, "Prior Day Halfback: " + str.tostring(yMiddle), xloc.bar_index, yloc.price, color=middleLineColor, style=label.style_label_down, size=size.small, textcolor=color.white, textalign=text.align_right)
    else
        label.set_xy(middleLabel, bar_index, yMiddle)
        label.set_text(middleLabel, "Prior Day Halfback: " + str.tostring(yMiddle))
        label.set_color(middleLabel, middleLineColor)
        label.set_style(middleLabel, label.style_label_down)

if showLowLabel
    if na(lowLabel)
        lowLabel := label.new(bar_index, yLow, "Prior Day Low: " + str.tostring(yLow), xloc.bar_index, yloc.price, color=lowLineColor, style=label.style_label_up, size=size.small, textcolor=color.white, textalign=text.align_right)
    else
        label.set_xy(lowLabel, bar_index, yLow)
        label.set_text(lowLabel, "Prior Day Low: " + str.tostring(yLow))
        label.set_color(lowLabel, lowLineColor)
        label.set_style(lowLabel, label.style_label_up)

//end

//pivots
//start


pivotTypeInput = input.string(title="Type", defval="Traditional", options=["Traditional", "Fibonacci", "Woodie", "Classic", "DM", "Camarilla"])
pivotAnchorInput = input.string(title="Pivots Timeframe", defval="Auto", options=["Auto", "Daily", "Weekly", "Monthly", "Quarterly", "Yearly", "Biyearly", "Triyearly", "Quinquennially", "Decennially"])
maxHistoricalPivotsInput = input.int(title="Number of Pivots Back", defval=15, minval=1, maxval=200, display = display.data_window)
isDailyBasedInput = input.bool(title="Use Daily-based Values", defval=true, display = display.data_window, tooltip="When this option is unchecked, Pivot Points will use intraday data while calculating on intraday charts. If Extended Hours are displayed on the chart, they will be taken into account during the pivot level calculation. If intraday OHLC values are different from daily-based values (normal for stocks), the pivot levels will also differ.")
showLabelsInput = input.bool(title="Show Labels", defval=true, group="labels", display = display.data_window)
showPricesInput = input.bool(title="Show Prices", defval=true, group="labels", display = display.data_window)
positionLabelsInput = input.string("Left", "Labels Position", options=["Left", "Right"], group="labels", display = display.data_window)
linewidthInput = input.int(title="Line Width", defval=1, minval=1, maxval=100, group="levels", display = display.data_window)

DEFAULT_COLOR = #FB8C00
pColorInput = input.color(DEFAULT_COLOR, "P‏  ‏  ‏", inline="P", group="levels", display = display.data_window)
pShowInput = input.bool(true, "", inline="P", group="levels", display = display.data_window)
s1ColorInput = input.color(DEFAULT_COLOR, "S1", inline="S1/R1" , group="levels", display = display.data_window)
s1ShowInput = input.bool(true, "", inline="S1/R1", group="levels", display = display.data_window)
r1ColorInput = input.color(DEFAULT_COLOR, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R1", inline="S1/R1", group="levels", display = display.data_window)
r1ShowInput = input.bool(true, "", inline="S1/R1", group="levels", display = display.data_window)
s2ColorInput = input.color(DEFAULT_COLOR, "S2", inline="S2/R2", group="levels", display = display.data_window)
s2ShowInput = input.bool(true, "", inline="S2/R2", group="levels", display = display.data_window)
r2ColorInput = input.color(DEFAULT_COLOR, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R2", inline="S2/R2", group="levels", display = display.data_window)
r2ShowInput = input.bool(true, "", inline="S2/R2", group="levels", tooltip = "Not applicable to DM", display = display.data_window)
s3ColorInput = input.color(DEFAULT_COLOR, "S3", inline="S3/R3", group="levels", display = display.data_window)
s3ShowInput = input.bool(true, "", inline="S3/R3", group="levels", display = display.data_window)
r3ColorInput = input.color(DEFAULT_COLOR, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R3", inline="S3/R3", group="levels", display = display.data_window)
r3ShowInput = input.bool(true, "", inline="S3/R3", group="levels", tooltip = "Not applicable to DM", display = display.data_window)
s4ColorInput = input.color(DEFAULT_COLOR, "S4", inline="S4/R4", group="levels", display = display.data_window)
s4ShowInput = input.bool(true, "", inline="S4/R4", group="levels", display = display.data_window)
r4ColorInput = input.color(DEFAULT_COLOR, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R4", inline="S4/R4", group="levels", display = display.data_window)
r4ShowInput = input.bool(true, "", inline="S4/R4", group="levels", tooltip = "Not applicable to: Fibonacci, DM", display = display.data_window)
s5ColorInput = input.color(DEFAULT_COLOR, "S5", inline="S5/R5", group="levels", display = display.data_window)
s5ShowInput = input.bool(true, "", inline="S5/R5", group="levels", display = display.data_window)
r5ColorInput = input.color(DEFAULT_COLOR, "‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏R5", inline="S5/R5", group="levels", display = display.data_window)
r5ShowInput = input.bool(true, "", inline="S5/R5", group="levels", tooltip = "Not applicable to: Fibonacci, Woodie, Classic, DM", display = display.data_window)

type graphicSettings
    string levelName
    color levelColor
    bool showLevel

var graphicSettingsArray = array.from(
      graphicSettings.new(" P", pColorInput, pShowInput),
      graphicSettings.new("R1", r1ColorInput, r1ShowInput), graphicSettings.new("S1", s1ColorInput, s1ShowInput),
      graphicSettings.new("R2", r2ColorInput, r2ShowInput), graphicSettings.new("S2", s2ColorInput, s2ShowInput),
      graphicSettings.new("R3", r3ColorInput, r3ShowInput), graphicSettings.new("S3", s3ColorInput, s3ShowInput),
      graphicSettings.new("R4", r4ColorInput, r4ShowInput), graphicSettings.new("S4", s4ColorInput, s4ShowInput),
      graphicSettings.new("R5", r5ColorInput, r5ShowInput), graphicSettings.new("S5", s5ColorInput, s5ShowInput))

autoAnchor = switch
    timeframe.isintraday => timeframe.multiplier <= 15 ? "1D" : "1W"
    timeframe.isdaily    => "1M"
    => "12M"

pivotTimeframe = switch pivotAnchorInput
    "Auto"      => autoAnchor
    "Daily"     => "1D"
    "Weekly"    => "1W"
    "Monthly"   => "1M"
    "Quarterly" => "3M"
    => "12M"

//@variable The number of years in the selected Pivot period
pivotYearMultiplier = switch pivotAnchorInput
    "Biyearly"       => 2
    "Triyearly"      => 3
    "Quinquennially" => 5
    "Decennially"    => 10
    => 1

//@variable The number of values in the pivots of the selected type
numOfPivotLevels = switch pivotTypeInput
    "Traditional" => 11
    "Camarilla"   => 11
    "Woodie"      => 9
    "Classic"     => 9
    "Fibonacci"   => 7
    "DM"          => 3

type pivotGraphic
    line pivotLine
    label pivotLabel

method delete(pivotGraphic graphic) =>
    graphic.pivotLine.delete()
    graphic.pivotLabel.delete()

var drawnGraphics = matrix.new<pivotGraphic>()

localPivotTimeframeChange = timeframe.change(pivotTimeframe) and year % pivotYearMultiplier == 0
securityPivotTimeframeChange = timeframe.change(timeframe.period) and year % pivotYearMultiplier == 0

pivotTimeframeChangeCounter(condition) => 
    var count = 0
    if condition and bar_index > 0
        count += 1
    count

localPivots = ta.pivot_point_levels(pivotTypeInput, localPivotTimeframeChange)
securityPivotPointsArray = ta.pivot_point_levels(pivotTypeInput, securityPivotTimeframeChange)

securityTimeframe = timeframe.isintraday ? "1D" : timeframe.period
[securityPivots, securityPivotCounter] = request.security(syminfo.tickerid, pivotTimeframe, [securityPivotPointsArray, pivotTimeframeChangeCounter(securityPivotTimeframeChange)], lookahead = barmerge.lookahead_on)
pivotPointsArray = isDailyBasedInput ? securityPivots : localPivots

//@function Sets the ending points of the currently active pivots to `endTime`.
affixOldPivots(endTime) =>
    if drawnGraphics.rows() > 0
        lastGraphics = drawnGraphics.row(drawnGraphics.rows() - 1)

        for graphic in lastGraphics
            graphic.pivotLine.set_x2(endTime)
            if positionLabelsInput == "Right"
                graphic.pivotLabel.set_x(endTime)

//@function Draws pivot lines and labels from `startTime` to the approximate end of the period.
drawNewPivots(startTime) =>
    
    newGraphics = array.new<pivotGraphic>()

    for [index, coord] in pivotPointsArray
        levelSettings = graphicSettingsArray.get(index)
        if not na(coord) and levelSettings.showLevel
            lineEndTime = startTime + timeframe.in_seconds(pivotTimeframe) * 1000 * pivotYearMultiplier
            pivotLine = line.new(startTime, coord, lineEndTime, coord, xloc = xloc.bar_time, color=levelSettings.levelColor, width=linewidthInput)
            pivotLabel = label.new(x = positionLabelsInput == "Left" ? startTime : lineEndTime,
                               y = coord,
                               text = (showLabelsInput ? levelSettings.levelName + " " : "") + (showPricesInput ? "(" + str.tostring(coord, format.mintick) + ")" : ""),
                               style = positionLabelsInput == "Left" ? label.style_label_right : label.style_label_left,
                               textcolor = levelSettings.levelColor,
                               color = #00000000,
                               xloc=xloc.bar_time)
            
            newGraphics.push(pivotGraphic.new(pivotLine, pivotLabel))
    
    drawnGraphics.add_row(array_id = newGraphics)

    if drawnGraphics.rows() > maxHistoricalPivotsInput
        oldGraphics = drawnGraphics.remove_row(0)
        
        for graphic in oldGraphics
            graphic.delete()


localPivotDrawConditionStatic = not isDailyBasedInput and localPivotTimeframeChange
securityPivotDrawConditionStatic = isDailyBasedInput and securityPivotCounter != securityPivotCounter[1]

var isMultiYearly = array.from("Biyearly", "Triyearly", "Quinquennially", "Decennially").includes(pivotAnchorInput)
localPivotDrawConditionDeveloping = not isDailyBasedInput and time_close == time_close(pivotTimeframe) and not isMultiYearly 
securityPivotDrawConditionDeveloping = false

if (securityPivotDrawConditionStatic or localPivotDrawConditionStatic)
    affixOldPivots(time)
    drawNewPivots(time)

// If possible, draw pivots from the beginning of the chart if none were found
var FIRST_BAR_TIME = time
if (barstate.islastconfirmedhistory and drawnGraphics.columns() == 0)

    if not na(securityPivots) and securityPivotCounter > 0
        if isDailyBasedInput
            drawNewPivots(FIRST_BAR_TIME)
        else 
            runtime.error("Not enough intraday data to calculate Pivot Points. Lower the Pivots Timeframe or turn on the 'Use Daily-based Values' option in the indicator settings.")
    else
        runtime.error("Not enough data to calculate Pivot Points. Lower the Pivots Timeframe in the indicator settings.")

//end